import * as React from "react";
import styled, { css } from "styled-components";
import { FlowChart } from "@mrblenny/react-flow-chart";
import {
  Content,
  Page,
  Sidebar,
  SidebarItem,
  Button,
  Label,
  TextField,
  Container,
  RadioGroup
} from "./components";
import CustomPort from "./CustomPort";

import Select from "react-select";
import { CanvasContext } from "./CanvasContext";

const Message = styled.div`
  margin: 1.5rem auto;
  padding: 10px;
  background: rgba(0, 0, 0, 0.05);
`;

/**
 * id:-> AutoGenerated
 * type -> DropDown of input / output
 * properties -> MultiSelect
 */
const NODE_TYPES = {
  OUTPUT: "output",
  INPUT: "input"
};

const NODE_PROPERTY_VALUES = {
  YES: "yes",
  NO: "no",
  BOTH: "both"
};

const NODE_PROPERTIES = [
  { type: "value", label: "yes", value: NODE_PROPERTY_VALUES.YES },
  { type: "value", label: "no", value: NODE_PROPERTY_VALUES.NO },
  { type: "value", label: "both", value: NODE_PROPERTY_VALUES.BOTH }
];

const NODE_TYPE_OPTIONS = [
  { label: "output", value: NODE_TYPES.OUTPUT },
  { label: "input", value: NODE_TYPES.INPUT }
];

export const NodeDefault = styled.div`
  position: absolute;
  transition: 0.3s ease box-shadow, 0.3s ease margin-top;
  background: white;
  border-radius: 4px;
  min-width: 200px;
  ${props =>
    props.isSelected &&
    css`
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
      margin-top: -2px;
    `};
`;

const Circle = styled.div`
  position: absolute;
  width: 150px;
  height: 150px;
  padding: 30px;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #555;
  color: white;
  border-radius: 50%;
  ${props =>
    props.isSelected &&
    css`
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
      margin-top: -2px;
    `};
`;

const DarkBox = styled.div`
  position: absolute;
  padding: 30px;
  background: #555;
  color: white;
  border-radius: 10px;
  min-width: 200px;
  justify-content: center;
  display: flex;
  ${props =>
    props.isSelected &&
    css`
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
      margin-top: -2px;
    `};
`;

const PortList = ({ onMount }) => <div>{onMount()}</div>;

const CustomNode = React.forwardRef(
  ({ node: { type, ...rest }, children, ...otherProps }, ref) => {
    if (type === NODE.CONDITION) {
      return (
        <Circle ref={ref} type={type} {...otherProps}>
          {children}
        </Circle>
      );
    }
    return (
      <DarkBox ref={ref} type={type} {...otherProps}>
        {children}
      </DarkBox>
    );
  }
);

const NodeInner = ({ node, ...otherProps }) => {
  const { type, ...rest } = node;
  let json = null;
  if (type === NODE.CONDITION && rest.condition) {
    json = rest.condition;
  } else if (rest.fields) {
    json = rest.fields;
  }

  return <div>Test</div>;
};

const AddPortsToSelectedItem = () => {
  return (
    <React.Fragment>
      <CanvasContext.Consumer>
        {({
          onPortSelect,
          store: {
            fields: { newPort }
          }
        }) => (
          <React.Fragment>
            <Message>Add Ports To Selected Item</Message>
            <Label>Node Type</Label>
            <div className="form-group">
              <Select
                name="field"
                styles={customStyles}
                isDisabled={false}
                isLoading={false}
                isRtl={false}
                isSearchable={true}
                options={NODE_TYPE_OPTIONS}
                onChange={(option, b) =>
                  onPortSelect({ name: b.name, value: option.value })
                }
              />
            </div>
            {newPort && newPort.field === NODE_TYPES.OUTPUT && (
              <React.Fragment>
                <div className="form-group">
                  <Label>Node Properties</Label>
                  <Select
                    name="properties"
                    styles={customStyles}
                    options={NODE_PROPERTIES}
                    onChange={(option, b) =>
                      onPortSelect({
                        name: b.name,
                        value: option.value,
                        field: option.type
                      })
                    }
                  />
                </div>
              </React.Fragment>
            )}
          </React.Fragment>
        )}
      </CanvasContext.Consumer>
    </React.Fragment>
  );
};

const RenderConditionFields = ({ conditionField }) => {
  const keys = Object.keys(conditionField);
  if (keys.length === 0) return "";
  return keys.map(key => (
    <CanvasContext.Consumer key={key}>
      {({
        onConditionFieldChange,
        store: {
          fields: { condition }
        }
      }) => {
        return (
          <React.Fragment>
            <Field
              item={conditionField[key]}
              name={key}
              onChange={onConditionFieldChange}
              value={condition[key]}
            />
            {condition[key] &&
              condition[key] === "URL" &&
              conditionField[key].field && (
                <RenderConditionFields
                  conditionField={conditionField[key].field(condition[key])}
                />
              )}
          </React.Fragment>
        );
      }}
    </CanvasContext.Consumer>
  ));
};

const customStyles = {
  menu: (provided, state) => ({
    ...provided,
    margin: 0,
    padding: 0
  }),

  input: provided => ({
    position: "relative",
    border: "none",
    display: "block",
    border: "none",
    margin: "0px auto",
    width: "100%",
    outline: "none !important",
    fontSize: "16px",
    color: "rgba(0, 0, 0, 0.8)"
  }),

  control: (provided, { selectProps: { width } }) => ({
    marginTop: "5%",
    border: "none",
    borderBottom: "1px solid #ddd",
    height: 24,
    width: "100%",
    backgroundColor: "transparent",
    margin: "10px 5px 15px 0px",
    outline: "none !important",
    fontSize: 16,
    display: "inline-flex",
    transition: "all 0.2s ease-in-out",
    background: "-webkit-linear-gradient(bottom, #51bbbe 50%, #51bbbe 50%)",
    background: "linear-gradient(to top, #51bbbe 50%, #51bbbe 50%)",
    backgroundPosition: "left bottom",
    backgroundSize: "0 1px",
    backgroundRepeat: "no-repeat"
  }),
  option: (provided, state) => ({
    ...provided
  }),

  singleValue: (provided, state) => {
    const opacity = state.isDisabled ? 0.5 : 1;
    const transition = "opacity 300ms";
    return { ...provided, opacity, transition };
  }
};

const Field = props => {
  const { item, name, onChange, value, isRequired } = props;
  if (item.type === "input")
    return (
      <React.Fragment>
        <div className="form-group">
          <TextField
            label={item.label}
            type="input"
            isRequired={isRequired}
            name={name}
            onChange={({ target: { value } }) => onChange(value, name)}
            value={value}
          />
        </div>
      </React.Fragment>
    );
  else if (item.type === "select")
    return (
      <React.Fragment>
        <div className="form-group">
          <Label htmlFor={name} className="material-label">
            {item.label}
          </Label>
          <Select
            styles={customStyles}
            id={name}
            options={item.options}
            required={isRequired}
            onChange={({ value }) => onChange(value, name)}
            // defaultInputValue={value}
            value={{
              label: value ? value : "Select...",
              value: value ? value : "Select..."
            }}
          />
        </div>
      </React.Fragment>
    );
  else if (item.type === "radio")
    return (
      <React.Fragment>
        <div className="form-group">
        <Label htmlFor={name} className="material-label">
            {item.label}
        </Label>
          <RadioGroup
            id={name}
            selected={value}
            options={item.options}
            onChange={({ target: { name, value } }) => onChange(value, name)}
            name={name}
          />
        </div>
      </React.Fragment>
    );
  return "Field Not Implemented";
};

const RenderFlowFields = ({ flowFields }) => {
  const keys = Object.keys(flowFields);
  if (keys.length === 0) return "";
  return keys.map(key => (
    <CanvasContext.Consumer key={key}>
      {({
        onFlowFieldsChange,
        store: {
          fields: { flow }
        }
      }) => (
        <React.Fragment>
          <Field
            item={flowFields[key]}
            name={key}
            onChange={onFlowFieldsChange}
            value={flow[key]}
          />
        </React.Fragment>
      )}
    </CanvasContext.Consumer>
  ));
};

const NodeFields = props => {
  const { node } = props;
  if (!node) return "";
  const {
    properties: { type }
  } = node;
  if (type === NODE.FLOW)
    return (
      <React.Fragment>
        <RenderFlowFields {...props} flowFields={flowFields} />
        <AddPortsToSelectedItem type="flow" />
      </React.Fragment>
    );
  return (
    <React.Fragment>
      <RenderConditionFields {...props} conditionField={conditionField} />
      <AddPortsToSelectedItem type="flow" />
    </React.Fragment>
  );
};

export class DragAndDropSidebar extends React.Component {
  render() {
    return (
      <CanvasContext.Consumer>
        {({
          store: { nodes, selected, ...rest },
          stateActions,
          getPortsOfSelectedNode,
          saveRecordToNode
        }) => {
          return (
            <Page>
              <Content>
                <FlowChart
                  chart={{ ...rest, nodes, selected }}
                  callbacks={stateActions ? stateActions : {}}
                  Components={{
                    Port: CustomPort,
                    Node: CustomNode,
                    NodeInner: NodeInner
                  }}
                />
              </Content>
              <Sidebar>
                <Container>
                  <Message>Drag and drop these items onto the canvas.</Message>
                  {!selected.id && <SideBarNodes />}

                  {selected.id && <NodeFields node={nodes[selected.id]} />}

                  {selected.id && <PortList onMount={getPortsOfSelectedNode} />}

                  {selected.id && (
                    <Button onClick={saveRecordToNode}>Save</Button>
                  )}
                </Container>
              </Sidebar>
            </Page>
          );
        }}
      </CanvasContext.Consumer>
    );
  }
}

const NODE = {
  CONDITION: "condition",
  FLOW: "flow"
};

const operatorOptions = {
  URL: [
    { label: "equal", value: "EQUAL" },
    { label: "not equal", value: "NOTEQUAL" }
  ]
};

const fieldOptions = [
  { label: "URL", value: "URL" },
  { label: "XPATH", value: "XPATH" }
];

const conditionField = {
  field: {
    type: "select",
    label: "Field",
    validations: [],
    options: fieldOptions,
    field: value => ({
      operator: {
        type: "select",
        label: "Operator",
        validations: [],
        options: operatorOptions[value]
      }
    })
  },

  value: {
    label: "Value",
    type: "input",
    validations: []
  }
};

const elementOptions = [
  { label: "BUTTON", value: "BUTTON" },
  { label: "INPUT", value: "INPUT" },
  { label: "DROPDOWN", value: "DROPDOWN" },
  { label: "RADIO", value: "RADIO" },
  { label: "DOB", value: "DOB" },
  { label: "CAPTCHA", value: "CAPTCHA" },
  { label: "TEXT", value: "TEXT" }
];
const optionalOptions = [
  { label: "TRUE", value: "TRUE" },
  { label: "FALSE", value: "FALSE" }
];

const actionTypes = [
  { label: "CLICK", value: "CLICK" },
  { label: "MOUSE_OVER", value: "MOUSE_OVER" },
  { label: "INPUT", value: "INPUT" },
  { label: "EXECUTE", value: "EXECUTE" },
  { label: "SLIDER", value: "SLIDER" }
];

const flowFields = {
  elementType: {
    label: "Element Type",
    type: "select",
    validations: [],
    isRequired: true,
    options: elementOptions
  },
  actionType: {
    label: "Action Type",
    isRequired: true,
    type: "select",
    options: actionTypes
  },
  value: {
    label: "Value",
    type: "input",
    isRequired: true,
    validations: []
  },
  selector: {
    label: "Selector",
    isRequired: true,
    type: "input",
    validations: [] // can be css / xpath
  },
  optional: {
    label: "Optional",
    type: "radio",
    options: optionalOptions
  }
};

const SideBarNodes = () => {
  return (
    <React.Fragment>
      <SidebarItem
        type={NODE.CONDITION}
        ports={{}}
        properties={{
          custom: "property",
          type: NODE.CONDITION
        }}
      />
      <SidebarItem
        type={NODE.FLOW}
        ports={{}}
        properties={{
          custom: "property",
          type: NODE.FLOW
        }}
      />
    </React.Fragment>
  );
};
